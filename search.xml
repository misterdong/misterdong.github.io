<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http header头字段解析</title>
      <link href="/2020/07/27/http-header-tou-zi-duan-jie-xi/"/>
      <url>/2020/07/27/http-header-tou-zi-duan-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>HTTP头字段（英语：HTTP header fields）是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分。它们定义了一个超文本传输协议事务中的操作参数。HTTP头部字段可以自己根据需要定义，因此可能在 Web 服务器和浏览器上发现非标准的头字段。</p><a id="more"></a><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>协议头的字段，是在请求（request）或响应（response）行（一条消息的第一行内容）之后传输的。协议头的字段是以明文的字符串格式传输，是以冒号分隔的键名与键值对，以回车(CR)加换行(LF)符号序列结尾。协议头部分的结尾以一个空白字段标识，结果就是，也就是传输两个连续的CR+LF。在历史上，很长的行曾经可能以多个短行的形式传输；在下一行的开头，输出一个空格(SP)或者一个水平制表符(HT)，表示它是一个后续行。在如今，这种换行形式已经被废弃。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><h3 id="字段名"><a href="#字段名" class="headerlink" title="字段名"></a>字段名</h3><p>在 RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234 和 RFC 7235 中，对一组核心字段进行了标准化。有一份关于这些字段的官方登记，以及一些列的补充规范，由IANA（The Internet Assigned Numbers Authority，互联网数字分配机构）维护。各个应用程序也可以自行定义额外的字段名和相应的值。IANA维护的头字段的<a href="https://www.iana.org/assignments/message-headers/message-headers.xml#perm-headers" target="_blank" rel="noopener">永久登记表</a>和<a href="https://www.iana.org/assignments/message-headers/message-headers.xml#prov-headers" target="_blank" rel="noopener">临时登记表</a>。</p><p>有时我们可以看到有些字段名称前加有<code>X-</code>前缀进行标识，是用来标识这是个非标准的协议头字段，这一惯例已在2012年6月被废弃。同样的曾经有使用<code>Downgraded-</code>的限制也在2013年3月被解除。</p><h3 id="大小限制"><a href="#大小限制" class="headerlink" title="大小限制"></a>大小限制</h3><p>标准中没有对每个协议头字段的名称和值的大小设置任何限制，也没有限制字段的个数。然而，出于实际场景及安全性的考虑，大部分的服务器、客户端和代理软件都会实施一些限制。例如，Apache 2.3服务器在默认情况下限制每个字段的大小不得超过8190字节，同时，单个请求中最多有100个头字段。</p><h3 id="常见请求字段"><a href="#常见请求字段" class="headerlink" title="常见请求字段"></a>常见请求字段</h3><table><thead><tr><th>协议头字段名</th><th>说明</th><th>示例</th><th>状态</th></tr></thead><tbody><tr><td>Accept</td><td>能够接受的回应内容类型（Content-Types）</td><td>Accept: text/plain</td><td>常设</td></tr><tr><td>Accept-Charset</td><td>能够接受的字符集</td><td><code>Accept-Charset: utf-8</code></td><td>常设</td></tr><tr><td>Accept-Encoding</td><td>能够接受的编码方式列表。参考<a href="https://zh.wikipedia.org/wiki/HTTP%E5%8E%8B%E7%BC%A9" target="_blank" rel="noopener">HTTP压缩</a>。</td><td><code>Accept-Encoding: gzip, deflate</code></td><td>常设</td></tr><tr><td>Accept-Language</td><td>能够接受的回应内容的自然语言列表。参考 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">内容协商</a> 。</td><td><code>Accept-Language: en-US</code></td><td>常设</td></tr><tr><td>Authorization</td><td>用于超文本传输协议的认证的认证信息</td><td><code>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code></td><td>常设</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">Cache-Control</a></td><td>用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td><td><code>Cache-Control: no-cache</code></td><td>常设</td></tr><tr><td>Content-Length</td><td>以 八位字节数组 （8位的字节）表示的请求体的长度</td><td><code>Content-Length: 348</code></td><td>常设</td></tr><tr><td>Content-Type</td><td>请求体的 多媒体类型 （用于POST和PUT请求中）</td><td><code>Content-Type: application/x-www-form-urlencoded</code></td><td>常设</td></tr><tr><td>Date</td><td>发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送)</td><td><code>Date: Tue, 15 Nov 1994 08:12:31 GMT</code></td><td>常设</td></tr><tr><td>User-Agent</td><td>浏览器的<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">浏览器身份标识字符串</a></td><td><code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</code></td><td>常设</td></tr><tr><td>Origin</td><td>发起一个针对 跨来源资源共享 的请求（要求服务器在回应中加入一个‘访问控制-允许来源’（’Access-Control-Allow-Origin’）字段）。</td><td><code>Origin: http://www.example-social-network.com</code></td><td>常设: 标准</td></tr><tr><td>Cookie</td><td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td><td><code>Cookie: $Version=1; Skin=new;</code></td><td>常设: 标准</td></tr></tbody></table><h3 id="常见响应字段"><a href="#常见响应字段" class="headerlink" title="常见响应字段"></a>常见响应字段</h3><table><thead><tr><th>字段名</th><th>说明</th><th>例子</th><th align="center">状态</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>指定哪些网站可参与到跨来源资源共享过程中</td><td><code>Access-Control-Allow-Origin: *</code></td><td align="center">临时</td></tr><tr><td>Accept-Patch</td><td>指定服务器支持的文件格式类型。</td><td><code>Accept-Patch: text/example;charset=utf-8</code></td><td align="center">常设</td></tr><tr><td>Accept-Ranges</td><td>这个服务器支持哪些种类的部分内容范围</td><td><code>Accept-Ranges: bytes</code></td><td align="center">常设</td></tr><tr><td>Age</td><td>这个对象在代理缓存中存在的时间，以秒为单位</td><td><code>Age: 12</code></td><td align="center">常设</td></tr><tr><td>Allow</td><td>对于特定资源有效的动作。针对HTTP/405这一错误代码而使用</td><td><code>Allow: GET, HEAD</code></td><td align="center">常设</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">Cache-Control</a></td><td>向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒</td><td><code>Cache-Control: max-age=3600</code></td><td align="center">常设</td></tr><tr><td>Connection</td><td>针对该连接所预期的选项</td><td><code>Connection: close</code></td><td align="center">常设</td></tr><tr><td>Content-Disposition</td><td>一个可以让客户端下载文件并建议文件名的头部。文件名需要用双引号包裹。</td><td><code>Content-Disposition: attachment; filename=&quot;fname.ext&quot;</code></td><td align="center">常设</td></tr><tr><td>Content-Encoding</td><td>在数据上使用的编码类型。参考 超文本传输协议压缩 。</td><td><code>Content-Encoding: gzip</code></td><td align="center">常设</td></tr><tr><td>Content-Language</td><td>内容所使用的语言</td><td><code>Content-Language: da</code></td><td align="center">常设</td></tr><tr><td>Content-Length</td><td>回应消息体的长度，以 字节 （8位为一字节）为单位</td><td><code>Content-Length: 348</code></td><td align="center">常设</td></tr><tr><td>Content-Location</td><td>所返回的数据的一个候选位置</td><td><code>Content-Location: /index.htm</code></td><td align="center">常设</td></tr><tr><td>Content-Range</td><td>这条部分消息是属于某条完整消息的哪个部分</td><td><code>Content-Range: bytes 21010-47021/47022</code></td><td align="center">常设</td></tr><tr><td>Content-Type</td><td>当前内容的<a href="https://zh.wikipedia.org/wiki/MIME" target="_blank" rel="noopener">MIME</a>类型</td><td><code>Content-Type: text/html; charset=utf-8</code></td><td align="center">常设</td></tr><tr><td>Date</td><td>此条消息被发送时的日期和时间(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td><code>Date: Tue, 15 Nov 1994 08:12:31 GMT</code></td><td align="center">常设</td></tr><tr><td>Expires</td><td>指定一个日期/时间，超过该时间则认为此回应已经过期</td><td><code>Expires: Thu, 01 Dec 1994 16:00:00 GMT</code></td><td align="center">常设: 标准</td></tr><tr><td>Last-Modified</td><td>所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td><code>Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</code></td><td align="center">常设</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/HTTP_Location" target="_blank" rel="noopener">Location</a></td><td>用来 进行重定向，或者在创建了某个新资源时使用。</td><td><code>Location: http://www.w3.org/pub/WWW/People.html</code></td><td align="center">常设</td></tr><tr><td>Proxy-Authenticate</td><td>要求在访问代理时提供身份认证信息。</td><td><code>Proxy-Authenticate: Basic</code></td><td align="center">常设</td></tr><tr><td>Refresh</td><td>用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至“<code>http://www.w3.org/pub/WWW/People.html</code>”。</td><td><code>Refresh: 5; url=http://www.w3.org/pub/WWW/People.html</code></td><td align="center">专利并非标准Netscape实现的扩展，但大部分网页浏览器也支持。</td></tr><tr><td>Retry-After</td><td>如果某个实体临时不可用，则，此协议头用来告知客户端日后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td><td>Example 1: <code>Retry-After: 120</code>Example 2: <code>Retry-After: Fri, 07 Nov 2014 23:59:59 GMT</code></td><td align="center">常设</td></tr><tr><td>Server</td><td>服务器的名字</td><td><code>Server: Apache/2.4.1 (Unix)</code></td><td align="center">常设</td></tr><tr><td>Set-Cookie</td><td><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">HTTP cookie</a></td><td><code>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</code></td><td align="center">常设: 标准</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka原理及与Zookeeper的比较</title>
      <link href="/2019/08/02/eureka-yuan-li-ji-yu-zookeeper-de-bi-jiao/"/>
      <url>/2019/08/02/eureka-yuan-li-ji-yu-zookeeper-de-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p><em>Eureka</em>是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。目前1.X版本已停止维护，2.X版本未开源。</p><p><em>ZooKeeper</em>是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><a id="more"></a><h4 id="Eureka原理"><a href="#Eureka原理" class="headerlink" title="Eureka原理"></a>Eureka原理</h4><p>服务启动后向Eureka注册，Eureka Server会将注册信息想其它Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p><p>当服务注册中心Eureka Server检测到服务提供者因为宕机、网络原因不可用时，则在服务注册中心将服务置为<code>DOWN</code>状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。</p><p>服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，则认为服务宕机，注销该实例。</p><h4 id="作为注册中心"><a href="#作为注册中心" class="headerlink" title="作为注册中心"></a>作为注册中心</h4><h5 id="Zookeeper-保证CP"><a href="#Zookeeper-保证CP" class="headerlink" title="Zookeeper 保证CP"></a>Zookeeper 保证CP</h5><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的事几分钟以前的注册信息，但不能接受服务直接宕掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其它几点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30～120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</p><p>在使用dubbo作为微服务框架，zookeeper作为注册中心时，由于服务提供者的信息时缓存在服务消费者本地的，所以当zk宕机不可用时，服务之间也是可以进行正常的服务调用的，不过由于zk不提供服务注册，无法与刚启动的服务进行服务通讯。</p><h5 id="Eureka保证AP"><a href="#Eureka保证AP" class="headerlink" title="Eureka保证AP"></a>Eureka保证AP</h5><p>Eureka在设计时有限保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而且Eureka的客户端在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就可以保证服务可用，只不过查到的信息不是最新的（不保证强一致性）。除此之外，Eureka还有一种自我保护机制，如果15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心除了网络故障，此时会出现一下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它几点</li><li>当网络稳定时，当前实例新的注册信息会被同步至其它节点</li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud和Dubbo的差异对比</title>
      <link href="/2019/08/01/spring-cloud-he-dubbo-de-chai-yi-dui-bi/"/>
      <url>/2019/08/01/spring-cloud-he-dubbo-de-chai-yi-dui-bi/</url>
      
        <content type="html"><![CDATA[<p>Dubbo，阿里巴巴服务化治理的核心框架，一款高性能的RPC框架，后捐献给apache基金会。</p><p>Spring Cloud，spring出品的一款微服务架构框架集，解决了在微服务部署中所遇到的大部分问题。</p><p>Spring Cloud 和 Dubbo作为当前市场主流的微服务框架，在不同的公司都有各自使用，针对两者的不同点极其各自的作用，现做出比较。</p><a id="more"></a><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><ul><li>Spring Cloud 使用 Eureka作为注册中心，同时也支持第三方注册中心，如Zookeeper，Nacos等。</li><li>Dubbo 目前市场上一般采用Zookeeper作为注册中心，同样支持其他配置中心，如Multicast，Nacos,Redis等，官方推荐使用Zookeeper。</li></ul><blockquote><p>Eureka和Zookeeper的比较不在本篇内容中，会单独另开一篇。</p></blockquote><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>Spring Cloud 采用rest调用，相比于 RPC，更加<strong>轻量化和灵活</strong>（服务之间只依赖一纸契约，不存在代码级别的强依赖），有利于<strong>跨语言服务的实现</strong>，以及服务的发布。</li><li>Dubbo采用面向接口代理的高性能RPC调用，服务以接口为粒度，为开发者屏蔽远程调用底层细节。调用者需要引入服务提供者提供的jar包依赖，包含一定侵入性。</li></ul><h4 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h4><ul><li>Spring Cloud 采用 <strong>http restful</strong>通讯协议， 但也不是强绑定，也可以使用 RPC 库，或者采用 HTTP 2.0 + 长链接方式，可以通过Fegin 可以灵活设置。。</li><li>Dubbo 默认推荐通讯协议 <strong>dubbo://**，除此外还可以采用 rmi://，hession://，http://，webservice://，thrift://，memcached://，redis://，rest://，具体差异点请参照附表</strong>dubbo协议对比**。</li></ul><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul><li>Spring Cloud 全家桶解决了分布式中所遇到的大部分问题，包含了注册中心（Eureka），负载均衡器（Ribbon），客户端调用工具（REST和Feign），分布式配置中心（Config），服务保护熔断器（Hystrix）,服务网关（Zuul Gateway）,服务链路（Sleuth），消息总线（Bus）。</li><li>Dubbo 只是实现服务治理，缺少分布式配置中心、网关、链路、总线等，如果需要用到这些组件，需要整合其他框架。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上所述：无论是Spring  Cloud还是Dubbo都有着各自的优点和缺点，在使用Spring Cloud时，需要使用大量spring的组件，在学习使用过程中带来一定的学习成本。使用dubbo的话，仅仅使用dubbo自带的服务治理并不能满足我们要求，在配置中心，网关，链路等方面都需要单独开发，带来了一定的开发和运维成本。</p><p>附表：dubbo协议对比</p><table><thead><tr><th>协议</th><th>连接个数</th><th>连接方式</th><th>传输协议</th><th>传输方式</th><th>序列化</th><th>适用范围</th><th>适用场景</th></tr></thead><tbody><tr><td>dubbo://</td><td>单连接</td><td>长连接</td><td>TCP</td><td>NIO异步传输</td><td>Hessian二进制序列化</td><td>传入传出数据包较小（建议小于100k）</td><td>常规方法调用</td></tr><tr><td>rmi://</td><td>多连接</td><td>短连接</td><td>TCP</td><td>同步传输</td><td>Java标准二进制序列化</td><td>消费者与提供者个数差不多，可传文件</td><td>常规方法调用</td></tr><tr><td>hessian://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>Hessian二进制序列化</td><td>传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件</td><td>页面传输，文件传输</td></tr><tr><td>http://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>表单序列化</td><td>提供者比消费者个数多，可用表单或URL传入参数，暂不支持传文件</td><td>需同时给应用程序和浏览器 JS 使用的服务</td></tr><tr><td>webservice://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>SOAP文本序列化</td><td></td><td>系统集成，跨语言调用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习之旅</title>
      <link href="/2019/07/23/redis-xue-xi-zhi-lu/"/>
      <url>/2019/07/23/redis-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h4 id="redis过期时间"><a href="#redis过期时间" class="headerlink" title="redis过期时间"></a>redis过期时间</h4><p>消极方法（passive way）：在访问key时，如果发现过期，则进行删除 </p><p>积极方法（active way）：周期性的从设置了过期时间的key中选择一部分的key进行删除 </p><ol><li><p>随机测试20个带有timeout信息的key进行测试 </p></li><li><p>删除所有过期的key </p></li><li><p>如果超过25%的key被删除，则重复执行步骤1 </p></li></ol><a id="more"></a><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>当符合【条件】条件的时候，fork子进程，把数据写到dump.rdb快照文件，不会对主进程操作进行影响 </p><p>条件: </p><p>配置规则，config文件 </p><p>save seconds changes </p><p>save 900 1 </p><p>save 300 10 </p><p>save 60 10000 </p><p>save，会阻塞所有客户端的请求；bgsave，异步存储，不会阻塞 </p><p>flushall，配置规则存在的情况下，执行一次快照 </p><p>执行复制操作 </p><p>缺点：数据丢失 </p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>开启方式：redis.conf-&gt; append-only yes </p><blockquote><p>AOF 开启的情况下，默认从AOF中读取数据 </p></blockquote><h4 id="Redis的内存回收策略"><a href="#Redis的内存回收策略" class="headerlink" title="Redis的内存回收策略"></a>Redis的内存回收策略</h4><p>LRU</p><p>maxmemory-policy  ：</p><ul><li>noeviction(默认)</li><li>allkeys-lru 最少使用的数据淘汰</li><li>allkeys-random 随机移除某些数据</li><li>volatile-random/lru/ttl 从已经设置的过期时间的数据中随机淘汰/淘汰最少使用数据/淘汰即将过期的数据</li></ul><h4 id="Redis单线程为什么性能高"><a href="#Redis单线程为什么性能高" class="headerlink" title="Redis单线程为什么性能高"></a>Redis单线程为什么性能高</h4><p>采用多路复用机制</p><h4 id="Lua脚本在Redis中的应用"><a href="#Lua脚本在Redis中的应用" class="headerlink" title="Lua脚本在Redis中的应用"></a>Lua脚本在Redis中的应用</h4><ol><li>在应用中需要保证多个命令保证原子性，需要时用Lua脚本进行处理</li><li>在使用pipeline管道模型时，减少网络开销取执行多个命令</li><li>复用性</li></ol><p>在lua脚本中执行redis的命令</p><p>redis.call(‘set’,’lua’,’value’)</p><p>local val = redis.call(‘get’,’lua’)</p><p>编写lua脚本文件，如demo.lua</p><pre class=" language-lua"><code class="language-lua"><span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'lua'</span><span class="token punctuation">)</span></code></pre><p>执行：</p><pre class=" language-shell"><code class="language-shell">./redis-cli --eval demo.lua</code></pre><p>例：基于lua脚本实现ip限流</p><p>便携lua文件 ratelimit.lua</p><pre class=" language-lua"><code class="language-lua"><span class="token keyword">local</span> key<span class="token operator">=</span><span class="token string">"ratelimit:"</span><span class="token operator">..</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">local</span> limit<span class="token operator">=</span><span class="token function">tonumber</span><span class="token punctuation">(</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">local</span> expireTime<span class="token operator">=</span>ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">local</span> times <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'incr'</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token keyword">if</span> times <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">then</span>  redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'expire'</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>expireTime<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">if</span> times <span class="token operator">></span> limit <span class="token keyword">then</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span class="token keyword">return</span> <span class="token number">1</span></code></pre><p>执行：</p><pre class=" language-shell"><code class="language-shell">./redis-cli --eval ratelimit.lua 192.167.0.2,10 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础入门</title>
      <link href="/2019/07/03/redis-ji-chu-ru-men/"/>
      <url>/2019/07/03/redis-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<p>redis ,基于key-value的数据存储系统，存储在内存中，读取速度快，支持持久化。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>String （字符串）</li><li>Hash（哈希）</li><li>List（列表）</li><li>Set（集合）</li><li>Sorted-Set（有序集合）</li></ul><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>不同的数据类型在redis当中有着不同的存储方式：</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>使用int/SDS进行存储，整数类型的数据使用int进行存储，复杂类型（字节类型，字符类型，浮点类型）使用SDS（simple dynamic string）进行存储。</p><p>当字符串长度小于1M时，每次扩容时加倍现有的空间，如果超过1M，每次扩容只会多扩容1M的空间，最大512M，</p><blockquote><p>字符串最大长度512M</p></blockquote><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>redis3.2之前使用linklist和ziplist进行存储，3.2之后采用quicklist（linklist+quicklist，由ziplist组成的双向链表，每个节点都是一个ziplist）进行存储。</p><p>应用场景：消息队列（lpush+brpop）、栈（lpush+lpop）</p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>数据结构：dict</p><p>Rehash：在dict内部，维护了两张哈希表，一张表时旧表，一张表时新表，当hashtable的大小需要动态变化时，旧表中的数据迁移到新表中，下一次变化，当前的新表又变成旧表。</p><p>渐进式rehash：为了避变rehash对服务器性能造成影响，服务器不是一次性将ht[0]中的所有键值对全部rehash到ht[1]中的，而是分多次、渐进式的：</p><ol><li>为ht[1]分配空间，让dict同时有ht[0]和ht[1]两个哈希表;</li><li>在字典中维护一个索引计数器变量rehashidx，并将它的值设置为0；</li><li>在rehash进行时，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]在rehashidx索引上 所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehash属性的值增1；</li><li>随着dict字典操作的不断执行，最终在某个时间点，ht[0]上的键值对都会被rehash到ht[1]上，此时rehashidx的值变为-1，rehash过程结束。</li></ol><p>使用场景：存储key-value格式的对象信息</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>数据结构：intset/hashtable(使用hashtable时，仅用key，value为null)。</p><p>使用场景：共同好友列表</p><h4 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h4><p>数据结构：ziplist/skiplist+hashtable</p><p> 使用场景：带有权重的元素列表，排行榜。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的锁</title>
      <link href="/2019/05/27/mysql-zhong-de-suo/"/>
      <url>/2019/05/27/mysql-zhong-de-suo/</url>
      
        <content type="html"><![CDATA[<h4 id="读写锁（共享锁，排他锁）"><a href="#读写锁（共享锁，排他锁）" class="headerlink" title="读写锁（共享锁，排他锁）"></a>读写锁（共享锁，排他锁）</h4><p>读锁是共享的，或者说是互相不阻塞的。多个用户在同一时刻可以同时读取一个资源，而互不干扰。<br>写锁是排他的，即一个写锁或阻塞其他的写锁和读锁。</p><a id="more"></a><p>加锁阶段：在该阶段能够进行加锁操作。在对不论什么数据进行读操作之前要申请并获得S锁（共享锁，其他事务能够继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其他事务不能再获得不论什么锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续运行。<br>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段。在该阶段仅仅能进行解锁操作不能再进行加锁操作。</p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>一种提供共享资源并发性的方式就是让锁定对象更具有选择性。</p><h5 id="表锁（table-lock）"><a href="#表锁（table-lock）" class="headerlink" title="表锁（table lock）"></a>表锁（table lock）</h5><p>表锁是MySQL中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。<br>在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的兵法写操作。另外，写锁闭读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列到前面（写锁可以插入到锁队列读锁的前面，反之读锁不能插入到锁队列写锁的前面）。</p><h5 id="行级锁（row-lock）"><a href="#行级锁（row-lock）" class="headerlink" title="行级锁（row lock）"></a>行级锁（row lock）</h5><p>行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。</p><h4 id="行锁，间隙锁，next-key锁"><a href="#行锁，间隙锁，next-key锁" class="headerlink" title="行锁，间隙锁，next-key锁"></a>行锁，间隙锁，next-key锁</h4><p> 行锁：record lock，记录锁<br> 间隙锁（辅助索引时）：以（主键，辅助索引）为间隙点，两个间隙点间的区域进行加锁。<br> next-key锁：包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认的枷锁方式。</p><p> 表结构：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tbl_1<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> unsigned <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>field<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">9</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_unicode_ci<span class="token punctuation">;</span></code></pre><p>如上，id为唯一自增主键，name为普通索引，field字段没有索引</p><table><thead><tr><th>id(主键)</th><th>name(二级索引)</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>6</td><td>5</td></tr><tr><td>8</td><td>5</td></tr><tr><td>10</td><td>5</td></tr><tr><td>13</td><td>11</td></tr></tbody></table><p> 1）InnoDB是通过给索引上的索引项进行加锁来进行锁定的，只有通过索引进行数据的检索，才能使用行锁，否则，将使用表锁。<br>查询一：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_1 <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><p>查询二：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_1 <span class="token keyword">WHERE</span> field<span class="token operator">=</span><span class="token string">"1"</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><p>上面查询一和查询二都会进行全表锁定。<br>2）任何非主键索引上的锁，最终都会追溯到主键上，即对主键索引进行加锁<br>查询三：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_1 <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">"2"</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><p>查询四：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_1 <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token string">"1"</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><p>上面查询三和查询四都锁定的都是id=1的那条记录。</p><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p><strong>间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的:</strong><br>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据<br><strong>innodb自动使用间隙锁的条件：</strong><br>（1）必须在RR级别下<br>（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</p><p><strong>区间的划分方式</strong><br>根据name列，我们可以将记录分为以下几个区间，（-∞，2），（2，4），（4，5），（5，11），（11，+∞）。<br>只要区间内可以插入数据，则可以认为有间隙<br><strong>区间的锁定方式</strong><br>当锁定name=4的记录时，锁定的区间范围为左边最近的区间加上右边最近的区间，即（2，4），（4，5），与之对应被锁定的记录为{id=1，name=2},{id=3，name=4},{id=6，name=5}。<br>验证：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_1  <span class="token keyword">WHERE</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token operator">=</span><span class="token string">'4'</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tbl_1 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 阻塞</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tbl_1 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 阻塞</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tbl_1 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 阻塞</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tbl_1 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 成功</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加评论功能--gitalk</title>
      <link href="/2019/05/11/hexo-tian-jia-ping-lun-gong-neng-gitalk/"/>
      <url>/2019/05/11/hexo-tian-jia-ping-lun-gong-neng-gitalk/</url>
      
        <content type="html"><![CDATA[<p>昨天朋友想搭建博客，向他推荐了hexo自建博客，问到是否可以进行评论，发现我这里也没有加评论功能。<br>开始打算用gitment做评论，但是在安装完成后，在登录github时，遇到了问题，跨域请求无法访问，采用了第二种，即 gitalk。</p><a id="more"></a><h4 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h4><p>gitalk : 一个基于 Github Issue 和 Preact 开发的评论插件。<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">详情</a></p><h4 id="Register-Application"><a href="#Register-Application" class="headerlink" title="Register Application"></a>Register Application</h4><p>github 上新建应用<br><img src="https://raw.githubusercontent.com/misterdong/img/master/blog/20190511173939.png"><br>填写相关信息<br><img src="https://raw.githubusercontent.com/misterdong/img/master/blog/20190511174046.png"><br>注册</p><p><img src="https://raw.githubusercontent.com/misterdong/img/master/blog/20190511174156.png"><br>生成Client ID 和 Client Secret</p><h4 id="gitalk-swig"><a href="#gitalk-swig" class="headerlink" title="gitalk.swig"></a>gitalk.swig</h4><p>新建/layout/_third-party/comments/gitalk.swig文件，并添加内容：</p><pre class=" language-script"><code class="language-script">{% if page.comments && theme.gitalk.enable %}<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/src/md5.min.js"></script><script type="text/javascript">    var gitalk = new Gitalk({        clientID: '{{ theme.gitalk.ClientID }}',        clientSecret: '{{ theme.gitalk.ClientSecret }}',        repo: '{{ theme.gitalk.repo }}',        owner: '{{ theme.gitalk.githubID }}',        admin: ['{{ theme.gitalk.adminUser }}'],        id: md5(tion.pathnam),        distractionFreeMode: '{{ theme.gitalk.distractionFreeMode   }}'    })    gitalk.render('gitalk-container')   </script>{% endif %}</code></pre><p>由于部分文章的评论区会报Error: Validation Failed,具体原因是由于 Github 限制 labal 长度不能超过 50引起的，该问题解决方案来自Gitalk项目仓 Issues115，通过MD5加密ID来缩短labal长度。<br>从GitHub下载md5.min.js文件，放置到themes\next\source\js\src\目录。[下载](<br><a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js</a></p><h4 id="comments-swig"><a href="#comments-swig" class="headerlink" title="comments.swig"></a>comments.swig</h4><p>修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上：</p><pre class=" language-script"><code class="language-script">{% elseif theme.gitalk.enable %}<div id="gitalk-container"></div></code></pre><h4 id="index-swig"><a href="#index-swig" class="headerlink" title="index.swig"></a>index.swig</h4><p>引入gitalk.swig，修改layout/_third-party/comments/index.swig，在最后一行添加内容：</p><pre class=" language-script"><code class="language-script">{% include 'gitalk.swig' %}</code></pre><h4 id="gitalk-styl"><a href="#gitalk-styl" class="headerlink" title="gitalk.styl"></a>gitalk.styl</h4><p>新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容：</p><pre class=" language-script"><code class="language-script">.gt-header a, .gt-comments a, .gt-popup aborder-bottom: none;.gt-container .gt-popup .gt-action.is--active:beforetop: 0.7em;</code></pre><h4 id="third-party-styl"><a href="#third-party-styl" class="headerlink" title="third-party.styl"></a>third-party.styl</h4><p>修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式：</p><pre class=" language-script"><code class="language-script">@import "gitalk";</code></pre><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>在主题配置文件next/_config.yml中添加如下内容：</p><pre class=" language-script"><code class="language-script">gitalk:  enable: true  githubID: 你的用户id    repo: 你的仓库名   # 例：misterdong.github.io  ClientID: 你的id  ClientSecret:你的secret  adminUser: misterdong #指定可初始化评论账户  distractionFreeMode: true</code></pre><p>至此，hexo添加gitalk评论功能完成，部分问题的解决方法，可参照<br><a href="https://liujunzhou.top/2018/8/10/gitalk-error/" target="_blank" rel="noopener">https://liujunzhou.top/2018/8/10/gitalk-error/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级路线</title>
      <link href="/2018/12/13/java-gao-ji-lu-xian/"/>
      <url>/2018/12/13/java-gao-ji-lu-xian/</url>
      
        <content type="html"><![CDATA[<p>Java高级开发学习大纲</p><a id="more"></a><h3 id="一、java多线程并发编程"><a href="#一、java多线程并发编程" class="headerlink" title="一、java多线程并发编程"></a>一、java多线程并发编程</h3><h4 id="1-1-java基础"><a href="#1-1-java基础" class="headerlink" title="1.1 java基础"></a>1.1 java基础</h4><h5 id="1-1-1-java程序运行堆栈分析"><a href="#1-1-1-java程序运行堆栈分析" class="headerlink" title="1.1.1 java程序运行堆栈分析"></a>1.1.1 java程序运行堆栈分析</h5><h5 id="1-1-2-线程状态"><a href="#1-1-2-线程状态" class="headerlink" title="1.1.2 线程状态"></a>1.1.2 线程状态</h5><h5 id="1-1-3-线程中止"><a href="#1-1-3-线程中止" class="headerlink" title="1.1.3 线程中止"></a>1.1.3 线程中止</h5><h5 id="1-1-4-内存屏障和CPU缓存"><a href="#1-1-4-内存屏障和CPU缓存" class="headerlink" title="1.1.4 内存屏障和CPU缓存"></a>1.1.4 内存屏障和CPU缓存</h5><h5 id="1-1-5-线程通信"><a href="#1-1-5-线程通信" class="headerlink" title="1.1.5 线程通信"></a>1.1.5 线程通信</h5><h5 id="1-1-6-线程封闭之ThreadLocal"><a href="#1-1-6-线程封闭之ThreadLocal" class="headerlink" title="1.1.6 线程封闭之ThreadLocal"></a>1.1.6 线程封闭之ThreadLocal</h5><h5 id="1-1-7-线程池应用及实现原理剖析"><a href="#1-1-7-线程池应用及实现原理剖析" class="headerlink" title="1.1.7 线程池应用及实现原理剖析"></a>1.1.7 线程池应用及实现原理剖析</h5><h4 id="1-2-线程安全之可见性问题"><a href="#1-2-线程安全之可见性问题" class="headerlink" title="1.2 线程安全之可见性问题"></a>1.2 线程安全之可见性问题</h4><h5 id="1-2-1-使用volatile解决可见性问题及阻止指令重排序"><a href="#1-2-1-使用volatile解决可见性问题及阻止指令重排序" class="headerlink" title="1.2.1 使用volatile解决可见性问题及阻止指令重排序"></a>1.2.1 使用volatile解决可见性问题及阻止指令重排序</h5><h5 id="1-2-2-线程安全之共享资源-不可变性-宽态条件-临界区"><a href="#1-2-2-线程安全之共享资源-不可变性-宽态条件-临界区" class="headerlink" title="1.2.2 线程安全之共享资源/不可变性/宽态条件/临界区"></a>1.2.2 线程安全之共享资源/不可变性/宽态条件/临界区</h5><h5 id="1-2-3-线程安全之原子操作"><a href="#1-2-3-线程安全之原子操作" class="headerlink" title="1.2.3 线程安全之原子操作"></a>1.2.3 线程安全之原子操作</h5><h5 id="1-2-4-Atomic相关类和CAS机制"><a href="#1-2-4-Atomic相关类和CAS机制" class="headerlink" title="1.2.4 Atomic相关类和CAS机制"></a>1.2.4 Atomic相关类和CAS机制</h5><h5 id="1-2-5-Java锁相关术语及同步关键字synchronized详解"><a href="#1-2-5-Java锁相关术语及同步关键字synchronized详解" class="headerlink" title="1.2.5 Java锁相关术语及同步关键字synchronized详解"></a>1.2.5 Java锁相关术语及同步关键字synchronized详解</h5><h5 id="1-2-6-Lock接口和ReentrantLock-ReadWriteLock"><a href="#1-2-6-Lock接口和ReentrantLock-ReadWriteLock" class="headerlink" title="1.2.6 Lock接口和ReentrantLock/ReadWriteLock"></a>1.2.6 Lock接口和ReentrantLock/ReadWriteLock</h5><h4 id="1-3-JUC并发编程包详解"><a href="#1-3-JUC并发编程包详解" class="headerlink" title="1.3 JUC并发编程包详解"></a>1.3 JUC并发编程包详解</h4><h5 id="1-3-1-AQS抽象队列同步器详解"><a href="#1-3-1-AQS抽象队列同步器详解" class="headerlink" title="1.3.1 AQS抽象队列同步器详解"></a>1.3.1 AQS抽象队列同步器详解</h5><h5 id="1-3-2-FutureTask源码剖析"><a href="#1-3-2-FutureTask源码剖析" class="headerlink" title="1.3.2 FutureTask源码剖析"></a>1.3.2 FutureTask源码剖析</h5><h5 id="1-3-3-并发容器类ConcurrentHashMap-ConcurrentSkipListMap"><a href="#1-3-3-并发容器类ConcurrentHashMap-ConcurrentSkipListMap" class="headerlink" title="1.3.3 并发容器类ConcurrentHashMap/ConcurrentSkipListMap"></a>1.3.3 并发容器类ConcurrentHashMap/ConcurrentSkipListMap</h5><h5 id="1-3-4-并发容器类ConcurrentSkipListSet-ConcurrentLinkedQueue-CopyOnWriteArrayList-LinkedBlockingQueue"><a href="#1-3-4-并发容器类ConcurrentSkipListSet-ConcurrentLinkedQueue-CopyOnWriteArrayList-LinkedBlockingQueue" class="headerlink" title="1.3.4 并发容器类ConcurrentSkipListSet/ConcurrentLinkedQueue/CopyOnWriteArrayList/LinkedBlockingQueue"></a>1.3.4 并发容器类ConcurrentSkipListSet/ConcurrentLinkedQueue/CopyOnWriteArrayList/LinkedBlockingQueue</h5><h5 id="1-3-5-Fock-Join框架"><a href="#1-3-5-Fock-Join框架" class="headerlink" title="1.3.5 Fock/Join框架"></a>1.3.5 Fock/Join框架</h5><h5 id="1-3-6-工具类扩展-信号量和栅栏和倒计数器"><a href="#1-3-6-工具类扩展-信号量和栅栏和倒计数器" class="headerlink" title="1.3.6 工具类扩展-信号量和栅栏和倒计数器"></a>1.3.6 工具类扩展-信号量和栅栏和倒计数器</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用node服务打开html文件</title>
      <link href="/2018/11/08/yong-node-fu-wu-da-kai-html-wen-jian/"/>
      <url>/2018/11/08/yong-node-fu-wu-da-kai-html-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>之前遇到一个需要本地模拟跨域现象的需求，苦于无法将前端项目以服务启动，然后在网上了这个，以nodejs方式启动。</p><a id="more"></a><blockquote><p>node server.js</p></blockquote><p>server.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入文件读取模块</span><span class="token keyword">var</span> documentRoot <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//需要访问的文件的存放目录（项目所在位置的文件夹路径）</span><span class="token keyword">var</span> server<span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> req<span class="token punctuation">.</span>url<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//客户端输入的url，例如如果输入localhost:8888/index.html</span>    <span class="token comment" spellcheck="true">//那么这里的url == /index.html </span>    <span class="token keyword">var</span> file <span class="token operator">=</span> documentRoot <span class="token operator">+</span> url<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//E:/PhpProject/html5/websocket/www/index.html </span>    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span> file <span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*        一参为文件路径        二参为回调函数            回调函数的一参为读取错误返回的信息，返回空就没有错误            二参为读取成功返回的文本内容    */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">writeHeader</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                <span class="token string">'content-type'</span> <span class="token punctuation">:</span> <span class="token string">'text/html;charset="utf-8"'</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;h1>404错误&lt;/h1>&lt;p>你要找的页面不存在&lt;/p>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">writeHeader</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                <span class="token string">'content-type'</span> <span class="token punctuation">:</span> <span class="token string">'text/html;charset="utf-8"'</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将index.html显示在客户端</span>            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器开启成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Git Page+Travis CI 搭建自动构建博客</title>
      <link href="/2018/10/31/hexo-git-page-travis-ci-da-jian-zi-dong-gou-jian-bo-ke/"/>
      <url>/2018/10/31/hexo-git-page-travis-ci-da-jian-zi-dong-gou-jian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>根据git page的特性，我们可以利用其特点利用<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a>做一个依据静态页面生成的博客，网上有很多类似的教程。同时，为了保存博客源码，以及创作的便利性，我们使用travis进行自动构建，免去了一些hexo的操作。</p><a id="more"></a><h4 id="创建github博客仓库"><a href="#创建github博客仓库" class="headerlink" title="创建github博客仓库"></a>创建github博客仓库</h4><h5 id="创建静态页面仓库"><a href="#创建静态页面仓库" class="headerlink" title="创建静态页面仓库"></a>创建静态页面仓库</h5><p>首先，在github上新建一个仓库，仓库名为：&lt;用户名&gt;.github.io,这个仓库用来存放博客的静态页面。<br><img src="https://raw.githubusercontent.com/misterdong/img/master/blog0067tRJGly1fwrk9pz0esj30lo0gwtb4.jpg"><br>关于github page的发布方式有以下三种方式，</p><ol><li>master分支直接发布</li><li>gh-pages分支发布</li><li>master分支下的/docs目录进行发布</li></ol><p>任性的人以上三种都不采用，我选用的是再建一个仓库去存放hexo博客的源码，每次生成文件后同步到静态页面的仓库，<br>&lt;用户名&gt;.github.io-&gt;Settings-&gt;GitHub Pages,source默认选择master即可。</p><h5 id="源码仓库创建"><a href="#源码仓库创建" class="headerlink" title="源码仓库创建"></a>源码仓库创建</h5><p>Hexo前置操作</p><blockquote><p>安装git<br>安装nodejs</p></blockquote><p>具体安装方式请另行寻找，不在本章范围内。</p><p>安装完以上两个软件后，即可进行hexo的安装。</p><ol><li>安装hexo项目<br><code>npm install -g hexo-cli</code></li><li>生成hexo项目<br><code>hexo init [projectname]</code></li><li>上传hexo源码到源码仓库<br><code>cd [projectname]</code><br><code>git add .</code><br><code>git commit -m &quot;提交源码&quot;</code><br><code>git push</code></li></ol><h4 id="使用Travis-CI进行自动构建"><a href="#使用Travis-CI进行自动构建" class="headerlink" title="使用Travis CI进行自动构建"></a>使用Travis CI进行自动构建</h4><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><p>登陆<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>,登陆时选择用github账号进行登陆，这样可以自动同步所有项目。<br>然后到github的setting页面中完成<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Access Token</a>的申请，将其作为环境变量GH_TOKEN的值保存在环境参数里。<br><img src="https://raw.githubusercontent.com/misterdong/img/master/blog0067tRJGly1fwrkadlb73j30k40ie408.jpg"></p><blockquote><p>关于github的token需要注意下，github有提示，token生成后显示一次，之后就再也看不到了。。。</p></blockquote><h5 id="创建travis设置文件"><a href="#创建travis设置文件" class="headerlink" title="创建travis设置文件"></a>创建travis设置文件</h5><p>让我们回到仓库本地目录，在该目录下新建一个.travis.yml文件，<br>文件内容如下：</p><pre class=" language-yml"><code class="language-yml">language: node_jsnode_js: stable# Travis-CI Cachingcache:  directories:    - node_modules# S: Build Lifecycleinstall:  - npm installbefore_script: # - npm install -g gulpscript:  - hexo gafter_script:  - cd ./public  - git init  - git config user.name "yourname"  - git config user.email "your email"  - git add .  - git commit -m "Update blog"  - git push --force "https://${GH_TOKEN}@${GH_REF}" master:master# E: Build LifeCyclebranches:  only:    - masterenv: global:   - GH_REF: github.com/misterdong/misterdong.github.io.git</code></pre><p>看到这里，我们就会发现travis其实就是一个帮你跑脚本的云主机命令行！<br>他按照我们指定的脚本顺序执行，先是install，再是before_script，script，最后是after_script.<br>branches指定了执行脚本的分支。<br>全局变量GH_REF指定了你的仓库地址。<br>我们首先用npm install在 travis 这台全新的主机上进行相关依赖的安装，这里就不需要重新再安装一遍 hexo 然后进行初始化了。安装完所需依赖之后，我们就可以直接使用 hexo 命令。<br>然后我们用hexo g命令来生成静态文件，生成的静态文件默认会被放在 public 目录下。<br>我们cd到public目录，用git init初始化仓库，进行相关信息的设置。<br>最后，travis-ci会将public目录下的文件全部 push 到你所创建的静态页面所在仓库的 master 分支上去。</p><p>当在hexo源码所在位置新写完文章后，用git方式进行提交，travis会发现文件变化，触发自动构建。<br>至此，我们完成了博客自动化构建的基本设置。</p><p>待续。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝色降落伞</title>
      <link href="/2018/10/07/lan-se-jiang-luo-san/"/>
      <url>/2018/10/07/lan-se-jiang-luo-san/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0067tRJGly1fw01r3fw56j30ti0lawif.jpg"></p><center>打开窗穿过走廊，下起雨来的弄堂</center><center>风里飘散的头发，门里空荡荡的家</center><center>我枕头下的梦想，我书包里的惆怅</center><center>她们等着我发芽，等到一地的落花</center><center>我蓝色的降落伞，在天空里那么孤单</center><center>飘向翻涌的人海，望着我被掩埋</center><center>那个青涩的男孩，在岁月里那么孤单</center><center>蓦然跳下老秋千，忽明忽暗地走远</center><a id="more"></a><center>打开窗穿过走廊，下起雨来的心房</center><center>风里飘散的头发，门外空荡荡的家</center><center>从不开始的冬天，从未晴朗的屋檐</center><center>没人教会我想念，烧成灰烬的木棉</center><center>我蓝色的降落伞，在天空里那么孤单</center><center>飘向翻涌的人海，望着我被掩埋</center><center>那个青涩的男孩，在岁月里那么孤单</center><center>他嘴角的那根烟，忽明忽暗地走远</center><center>蓝色的降落伞，在天空里那么孤单</center><center>飘向翻涌的人海，望着我被掩埋</center><center>那个青涩的男孩，在岁月里那么孤单</center><center>他嘴角的那根烟，忽明忽暗地走远</center>]]></content>
      
      
      <categories>
          
          <category> 歌词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书摘</title>
      <link href="/2018/09/30/shu-zhai/"/>
      <url>/2018/09/30/shu-zhai/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0067tRJGly1fvrnnz4atoj31400smdt1.jpg"></p><a id="more"></a><h4 id="《基督山伯爵》"><a href="#《基督山伯爵》" class="headerlink" title="《基督山伯爵》"></a>《基督山伯爵》</h4><ol><li>快乐或不快乐是一个秘密，只有自己和四面墙壁才知道，墙壁岁幼儿多，却没有舌头。</li><li>事实总会升起到人们的眼前，即使用全世界的泥土压住它也是枉然。</li><li>精神上的创伤就有这种特性，——它可以被掩盖起来，但却决不会收口；它是永远痛苦，永远一被触及就会流血，永远鲜血淋淋地留在心头。</li><li>世界上没有快乐或痛苦；只有一种状况与另一种状况的比较，只是如此而已。只有曾身受过最深切的悲哀的人，才能体会最大的快乐。我们必须经验过死的痛苦，才能体会到生的快乐。</li><li>永远不要忘记，在上帝揭露人的未来以前，人类的一切智慧是包含在四个字里面的：“等待”和“希望”。</li></ol><h4 id="《三体》"><a href="#《三体》" class="headerlink" title="《三体》"></a>《三体》</h4><ol><li><p>大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的她（他），而只是想象中的她（他），现实中的她（他）只是他们创造梦中情人的一个模版，他们迟早会发现梦中情人与模版之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。————《黑暗森林》</p></li><li><p>死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。————《死神永生》</p></li></ol><h4 id="《梦的解析》"><a href="#《梦的解析》" class="headerlink" title="《梦的解析》"></a>《梦的解析》</h4><ol><li>梦中出现的，都是我们或者于外部，或者于内心已经经历过的</li><li>很多清醒状态下不能记起的回忆，都能在梦里重现</li><li>有意识思考过的东西，常常只有在人不再去思考它们时，才出现在梦里</li><li>在梦里不是那些清醒状态下认为重要的东西，而是最无关紧要、最没有意义的记忆被挑选出来得以重现</li><li>梦能将感官世界的突然感受编织进梦的构图中，因此它们的出现就好像是一种预先安排好的、在引导中逐渐到来的结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书摘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018书单</title>
      <link href="/2018/09/27/2018-shu-dan/"/>
      <url>/2018/09/27/2018-shu-dan/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/13907842-81b60c03267c0415?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>只有一种方式是真正地在阅读。没有任何外力的帮助，你就是要读这本书。你什么都没有，只凭着内心的力量，玩味眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚的理解为止。——《如何阅读一本书》莫提默·J·艾德勒</p></blockquote><a id="more"></a><ul><li><input checked="" disabled="" type="checkbox"> 《教父三部曲》马里奥·普佐</li><li><input checked="" disabled="" type="checkbox"> 《小王子》安托万·德·圣-埃克苏佩里</li><li><input checked="" disabled="" type="checkbox"> 《外婆的道歉信》弗雷德里克·巴克曼</li><li><input checked="" disabled="" type="checkbox"> 《一个叫欧维的男人决定去死》弗雷德里克·巴克曼</li><li><input checked="" disabled="" type="checkbox"> 《了不起的盖茨比》菲茨杰拉德</li><li><input checked="" disabled="" type="checkbox"> 《月亮与六便士》</li><li><input checked="" disabled="" type="checkbox"> 《半小时漫画中国史》二混子</li><li><input checked="" disabled="" type="checkbox"> 《一个人的朝圣》蕾秋·乔伊斯</li><li><input checked="" disabled="" type="checkbox"> 《秘密》东野圭吾 </li><li><input checked="" disabled="" type="checkbox"> 《恶意》东野圭吾</li><li><input checked="" disabled="" type="checkbox"> 《三体全集》刘慈欣</li><li><input checked="" disabled="" type="checkbox"> 《基督山伯爵》大仲马</li><li><input disabled="" type="checkbox"> 《中国通史》吕思勉</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
